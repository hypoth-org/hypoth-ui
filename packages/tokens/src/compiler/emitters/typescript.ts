/**
 * TypeScript Types Emitter
 * Generates TypeScript types from tokens
 */

import { TOKEN_CATEGORIES, type TokenCategory } from "../../types/categories.js";
import type { ParsedToken } from "../parser.js";

/** TypeScript generation options */
export interface TypeScriptEmitOptions {
  /** Include JSDoc comments */
  includeJSDoc?: boolean;
  /** Include tokenVar helper function */
  includeHelper?: boolean;
}

/**
 * Generate TypeScript types from parsed tokens
 */
export function generateTypeScript(
  tokens: ParsedToken[],
  options: TypeScriptEmitOptions = {}
): string {
  const { includeJSDoc = true, includeHelper = true } = options;

  const lines: string[] = [];

  // Header
  lines.push("/**");
  lines.push(" * Generated token types");
  lines.push(" * DO NOT EDIT - this file is auto-generated by the token compiler");
  lines.push(" */");
  lines.push("");

  // Group tokens by category
  const tokensByCategory = new Map<TokenCategory, ParsedToken[]>();
  for (const token of tokens) {
    const category = token.path.split(".")[0] as TokenCategory;
    if (!tokensByCategory.has(category)) {
      tokensByCategory.set(category, []);
    }
    tokensByCategory.get(category)?.push(token);
  }

  // Generate category-specific types
  for (const category of TOKEN_CATEGORIES) {
    const categoryTokens = tokensByCategory.get(category);
    if (!categoryTokens || categoryTokens.length === 0) continue;

    const typeName = categoryToTypeName(category);
    const paths = categoryTokens
      .map((t) => `  | '${t.path}'`)
      .sort()
      .join("\n");

    if (includeJSDoc) {
      lines.push(`/** ${category} token paths */`);
    }
    lines.push(`export type ${typeName}TokenPath =`);
    lines.push(paths);
    lines.push(";");
    lines.push("");
  }

  // Generate union type of all token paths
  const allPaths = tokens
    .map((t) => `  | '${t.path}'`)
    .sort()
    .join("\n");

  if (includeJSDoc) {
    lines.push("/** All available token paths */");
  }
  lines.push("export type TokenPath =");
  lines.push(allPaths);
  lines.push(";");
  lines.push("");

  // Generate category type
  if (includeJSDoc) {
    lines.push("/** Token category types */");
  }
  lines.push("export type TokenCategory =");
  lines.push(TOKEN_CATEGORIES.map((c) => `  | '${c}'`).join("\n"));
  lines.push(";");
  lines.push("");

  // Generate helper function
  if (includeHelper) {
    if (includeJSDoc) {
      lines.push("/**");
      lines.push(" * Get a CSS variable reference for a token path");
      lines.push(' * @example tokenVar("color.primary") => "var(--color-primary)"');
      lines.push(" */");
    }
    lines.push("export function tokenVar(path: TokenPath): string {");
    lines.push("  return `var(--${path.replace(/\\./g, '-')})`;");
    lines.push("}");
    lines.push("");

    if (includeJSDoc) {
      lines.push("/**");
      lines.push(" * Get a CSS variable reference with fallback");
      lines.push(
        ' * @example tokenVarWithFallback("color.primary", "#000") => "var(--color-primary, #000)"'
      );
      lines.push(" */");
    }
    lines.push("export function tokenVarWithFallback(path: TokenPath, fallback: string): string {");
    lines.push("  return `var(--${path.replace(/\\./g, '-')}, ${fallback})`;");
    lines.push("}");
    lines.push("");
  }

  // Generate token metadata type
  if (includeJSDoc) {
    lines.push("/** Token metadata for a single token */");
  }
  lines.push("export interface TokenMetadata {");
  lines.push("  path: TokenPath;");
  lines.push("  cssVariable: string;");
  lines.push("  category: TokenCategory;");
  lines.push("  description?: string;");
  lines.push("}");
  lines.push("");

  return lines.join("\n");
}

/**
 * Generate TypeScript types for runtime use
 */
export function generateRuntimeTypes(): string {
  const lines: string[] = [];

  lines.push("/**");
  lines.push(" * Runtime token utilities");
  lines.push(" * Auto-generated - DO NOT EDIT");
  lines.push(" */");
  lines.push("");

  lines.push("export type { TokenPath, TokenCategory, TokenMetadata } from './index.js';");
  lines.push("export { tokenVar, tokenVarWithFallback } from './index.js';");
  lines.push("");

  lines.push("/** Theme mode values */");
  lines.push("export type ThemeMode = 'light' | 'dark' | 'high-contrast' | 'reduced-motion';");
  lines.push("");

  lines.push("/** Get current theme mode from document */");
  lines.push("export function getCurrentMode(): ThemeMode | undefined {");
  lines.push("  if (typeof document === 'undefined') return undefined;");
  lines.push("  return document.documentElement.dataset.mode as ThemeMode | undefined;");
  lines.push("}");
  lines.push("");

  lines.push("/** Set theme mode on document */");
  lines.push("export function setMode(mode: ThemeMode): void {");
  lines.push("  if (typeof document === 'undefined') return;");
  lines.push("  document.documentElement.dataset.mode = mode;");
  lines.push("}");
  lines.push("");

  lines.push("/** Get current brand from document */");
  lines.push("export function getCurrentBrand(): string | undefined {");
  lines.push("  if (typeof document === 'undefined') return undefined;");
  lines.push("  return document.documentElement.dataset.brand;");
  lines.push("}");
  lines.push("");

  lines.push("/** Set brand on document */");
  lines.push("export function setBrand(brand: string): void {");
  lines.push("  if (typeof document === 'undefined') return;");
  lines.push("  document.documentElement.dataset.brand = brand;");
  lines.push("}");
  lines.push("");

  return lines.join("\n");
}

/**
 * Convert category to TypeScript type name
 */
function categoryToTypeName(category: TokenCategory): string {
  if (category === "z-index") return "ZIndex";
  return category.charAt(0).toUpperCase() + category.slice(1);
}
